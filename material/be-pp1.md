# Pair Programming Task: - part 1: Building a User Authentication Server

## Overview
This guide walks you through building a basic Node.js/Express server that allows users to **register (sign up)** and **login**. We'll use MongoDB for data storage, bcrypt for password security, and Postman for testing.

**Estimated Time:** 1 hours  
**Difficulty Level:** Beginner to Intermediate  
**Technologies:** Node.js, Express, MongoDB, bcrypt, Postman

---

## Table of Contents
1. [Project Setup](#project-setup)
2. [Understanding the Architecture](#understanding-the-architecture)
3. [How bcrypt Works (Security Deep Dive)](#how-bcrypt-works-security-deep-dive)
4. [Step-by-Step Implementation](#step-by-step-implementation)
5. [Testing with Postman](#testing-with-postman)
6. [Common Issues & Troubleshooting](#common-issues--troubleshooting)

---

## Project Setup

### Prerequisites
- **Node.js** installed 
- **MongoDB** running locally or a MongoDB Atlas account (cloud)
- **Postman** installed for API testing
- **npm** (comes with Node.js)

### File Structure
```
project/
‚îú‚îÄ‚îÄ index.js                 # Entry point - Express app setup
‚îú‚îÄ‚îÄ config/
‚îÇ   ‚îî‚îÄ‚îÄ db.js               # Database connection
‚îú‚îÄ‚îÄ models/
‚îÇ   ‚îî‚îÄ‚îÄ userModel.js        # User schema and database structure
‚îú‚îÄ‚îÄ controllers/
‚îÇ   ‚îî‚îÄ‚îÄ userController.js   # Business logic for signup/login
‚îú‚îÄ‚îÄ routes/
‚îÇ   ‚îî‚îÄ‚îÄ userRouter.js       # API routes
‚îú‚îÄ‚îÄ middleware/
‚îÇ   ‚îî‚îÄ‚îÄ requireAuth.js      # Optional: protect routes
‚îú‚îÄ‚îÄ package.json            # Dependencies
‚îú‚îÄ‚îÄ .env                    # Environment variables (DO NOT COMMIT)
‚îî‚îÄ‚îÄ .env.example            # Example of .env file
```

---

## Understanding the Architecture

### How the Request Flows

```
User sends request to Postman
       ‚Üì
Express Server (index.js) receives request
       ‚Üì
Route Handler (userRouter.js) matches URL pattern
       ‚Üì
Controller Function (userController.js) executes logic
       ‚Üì
Model (userModel.js) interacts with MongoDB
       ‚Üì
Response sent back to Postman
```

### The Three Main Routes

| Route | Method | Purpose | Input |
|-------|--------|---------|-------|
| `/api/user/signup` | POST | Register a new user | `{ email, password }` |
| `/api/user/login` | POST | Log in existing user | `{ email, password }` |

---

## How bcrypt Works (Security Deep Dive)

### Why We Need bcrypt

**‚ùå WRONG WAY - Storing passwords as plain text:**
```javascript
// NEVER DO THIS!
const user = await User.create({ email, password: "mypassword123" });
```

If someone hacks your database, they get all passwords directly. This is a critical security vulnerability.

---

### What is bcrypt?

**bcrypt** is a password hashing library that uses a one-way encryption algorithm. It's specifically designed for passwords and is intentionally **slow** (which is a good thing!).

#### Key Concepts

**1. Hashing (One-Way Function)**
```
Plain Password: "mypassword123"
           ‚Üì (bcrypt.hash)
Hashed Value: "$2b$10$N9qo8uLOickgx2ZMRZoMyeIjZAgcg7b3XeKeUxWdeS86E36P4/DJm"
           ‚Üì (cannot reverse)
Original password is lost forever ‚úì
```

**2. Salting (Adding Randomness)**
```
Plain Password: "password123"
      + Salt (random string generated by bcrypt)
           ‚Üì
Unique Hash: different every time, even for same password!
```

**3. Cost Factor (Computational Difficulty)**
```javascript
const salt = await bcrypt.genSalt(10);
//                                ‚Üë
//     "10" = cost factor (higher = slower = more secure)
//     Takes longer to compute, makes brute-force attacks impractical
//     Typical values: 10-12
```

---

### The bcrypt Workflow

#### During Signup:

```javascript
// Step 1: User submits plain password
const password = "myPassword123!";

// Step 2: Generate salt (random string)
const salt = await bcrypt.genSalt(10);
// Example result: "$2b$10$abcdefghijklmnopqrstuv"

// Step 3: Hash password with salt
const hashedPassword = await bcrypt.hash(password, salt);
// Example result: "$2b$10$abcdefghijklmnopqrstu.N9qo8uLOickgx2ZMRZoMyeIjZAgcg7b3"

// Step 4: Store ONLY the hashedPassword in database
const user = await User.create({ 
  email: "user@example.com", 
  password: hashedPassword  // ‚Üê Hashed, not plain!
});
```

**Database now contains:**
```json
{
  "email": "user@example.com",
  "password": "$2b$10$abcdefghijklmnopqrstu.N9qo8uLOickgx2ZMRZoMyeIjZAgcg7b3"
}
```

#### During Login:

```javascript
// Step 1: User submits plain password
const password = "myPassword123!";

// Step 2: Retrieve user from database
const user = await User.findOne({ email });
// user.password contains: "$2b$10$abcdefghijklmnopqrstu.N9qo8uLOickgx2ZMRZoMyeIjZAgcg7b3"

// Step 3: Compare plain password with stored hash
const match = await bcrypt.compare(password, user.password);
// ‚Üì
// bcrypt.compare() automatically:
// - Takes the plain password
// - Hashes it with the salt embedded in user.password
// - Compares the result with user.password

// Step 4: Check result
if (match) {
  console.log("Password correct! User can login.");
} else {
  console.log("Password incorrect! Login denied.");
}
```

---

### Why bcrypt is Secure

| Feature | Benefit |
|---------|---------|
| **One-way** | Cannot decrypt hash back to password |
| **Salted** | Same password produces different hashes each time |
| **Slow** | Each hash takes ~0.3 seconds (makes brute-force impractical) |
| **Adaptive** | Cost factor can increase as computers get faster |

**Example:** Brute-forcing 1 million passwords would take ~3 days with bcrypt (vs milliseconds with MD5).

---

## Step-by-Step Implementation

### Step 0: Initialize Project & Install Dependencies

**Step 0.1: Create Project Directory**

Open terminal and run:
```bash
mkdir w7-bepp1
cd w7-bepp1
```

**Step 0.2: Initialize npm Repository**

```bash
npm init -y
```

This creates a `package.json` file with default settings.

**Step 0.3: Install Dependencies**

Run this single command to install all required packages:

```bash
npm install express mongoose dotenv bcryptjs validator cors
```

**What each package does:**
- `express`: Web framework for building the server
- `mongoose`: MongoDB database connector
- `dotenv`: Load environment variables from `.env` file
- `bcryptjs`: Password hashing library (for security)
- `validator`: Validate email format and password strength
- `cors`: Allow requests from different domains (frontend)

**Step 0.4: Install Development Dependencies**

```bash
npm install --save-dev nodemon
```

**What nodemon does:**
- Automatically restarts server when you save changes
- Saves time during development (no manual restart needed)
- Only needed during development, not in production

**Step 0.5: Verify Installation**

Check your `package.json` file. You should see all packages listed under `"dependencies"` and `"devDependencies"`:

```json
{
  "name": "w7-bepp1",
  "version": "1.0.0",
  "dependencies": {
    "bcryptjs": "^3.0.3",
    "cors": "^2.8.5",
    "dotenv": "^17.2.3",
    "express": "^5.1.0",
    "mongoose": "^8.20.0",
    "validator": "^13.15.23"
  },
  "devDependencies": {
    "nodemon": "^3.1.11"
  },
  "scripts": {
    "start": "node index.js",
    "dev": "nodemon index.js"
  }
}
```

**Step 0.6: Create Folder Structure**

Create the required directories:

```bash
mkdir config
mkdir models
mkdir controllers
mkdir routes
mkdir middleware
```

Or on Windows PowerShell:
```powershell
New-Item -ItemType Directory -Name config
New-Item -ItemType Directory -Name models
New-Item -ItemType Directory -Name controllers
New-Item -ItemType Directory -Name routes
New-Item -ItemType Directory -Name middleware
```

Your project structure should now look like:
```
w7-bepp1/
‚îú‚îÄ‚îÄ config/
‚îú‚îÄ‚îÄ models/
‚îú‚îÄ‚îÄ controllers/
‚îú‚îÄ‚îÄ routes/
‚îú‚îÄ‚îÄ middleware/
‚îú‚îÄ‚îÄ node_modules/         # Auto-created by npm
‚îú‚îÄ‚îÄ package.json          # Auto-created by npm init
‚îú‚îÄ‚îÄ package-lock.json     # Auto-created by npm
‚îî‚îÄ‚îÄ .env                  # You'll create this next
```

---

### Step 1: Setup Environment Variables

Create a `.env` file in your project root:

```env
PORT=4000
MONGO_URI=mongodb://localhost:27017/w7-bepp1
SECRET=76573c5c7b43c500325f985c60d544b5d62b543550ee7aa65f41e33bfdbec5f584ef8725818d6f9d26a7a27c773d868dd1b2d76bb9dbfb6b78c28060eb46120
```

**What each variable does:**
- `PORT`: Port your server runs on (4000)
- `MONGO_URI`: Connection string to MongoDB
- `SECRET`: Random secret key for JWT (JSON Web Tokens) - generate random hex

**To generate a random SECRET:**
- Visit: https://www.browserling.com/tools/random-hex
- Copy 64 bytes of random hex
- Paste into `.env`

**MongoDB Setup Options:**

**Option A: Local MongoDB**
```bash
# Windows - If MongoDB is installed
# MONGO_URI=mongodb://localhost:27017/w6-fepp
```

**Option B: MongoDB Atlas (Cloud)**
1. Go to https://www.mongodb.com/cloud/atlas
2. Create free account
3. Create a cluster
4. Get connection string
5. Replace `<password>` and `<username>`
   ```
   MONGO_URI=mongodb+srv://username:password@cluster0.xxxxx.mongodb.net/w7-bepp1
   ```

---

### Step 2: Create the User Model

**File:** `models/userModel.js`

```javascript
const mongoose = require('mongoose')

const Schema = mongoose.Schema

const userSchema = new Schema({
  email: {
    type: String,
    required: true,
    unique: true  // No duplicate emails!
  },
  password: {
    type: String,
    required: true
  }
})

module.exports = mongoose.model('User', userSchema)
```

**Explanation:**
- `email`: Must be unique (MongoDB enforces this)
- `password`: Required field (will store hashed password)
- `required: true`: Field cannot be empty
- `unique: true`: No two users can have same email

---

### Step 3: Setup Database Connection

**File:** `config/db.js`

```javascript
const mongoose = require("mongoose");

const connectDB = async () => {
  try {
    // Connect to MongoDB using connection string from .env
    const conn = await mongoose.connect(process.env.MONGO_URI);
    console.log(`MongoDB Connected: ${conn.connection.host}`);
  } catch (error) {
    console.log(error);
    process.exit(1);  // Exit if connection fails
  }
};

module.exports = connectDB;
```

**What it does:**
1. `mongoose.connect()`: Connects to MongoDB
2. Logs success message with hostname
3. If it fails, exits the process

---

### Step 4: Create the Controller

**File:** `controllers/userController.js`

This file contains the **business logic** for signup and login.

```javascript
const User = require("../models/userModel");
const bcrypt = require("bcryptjs");
const validator = require("validator");

// ============ SIGNUP CONTROLLER ============
const signupUser = async (req, res) => {
  // Step 1: Extract email and password from request body
  const { email, password } = req.body;

  try {
    // ===== VALIDATION =====
    
    // Check if fields are empty
    if (!email || !password) {
      throw Error("All fields must be filled");
    }

    // Validate email format using validator library
    if (!validator.isEmail(email)) {
      throw Error("Email not valid");
    }

    // Validate password strength
    // Must have: 8+ chars, uppercase, lowercase, number, symbol
    if (!validator.isStrongPassword(password)) {
      throw Error("Password not strong enough");
    }

    // Check if email already exists in database
    const exists = await User.findOne({ email });
    if (exists) {
      throw Error("Email already in use");
    }

    // ===== HASH PASSWORD =====
    
    // Generate salt (cost factor = 10)
    const salt = await bcrypt.genSalt(10);
    
    // Hash password with salt
    const hash = await bcrypt.hash(password, salt);

    // ===== CREATE USER =====
    
    // Store user with hashed password (NOT plain password!)
    const user = await User.create({ 
      email, 
      password: hash  // ‚Üê Hashed password!
    });

    // Send success response
    res.status(200).json({ user });

  } catch (error) {
    // Send error response
    res.status(400).json({ error: error.message });
  }
};

// ============ LOGIN CONTROLLER ============
const loginUser = async (req, res) => {
  // Step 1: Extract email and password from request body
  const { email, password } = req.body;

  try {
    // ===== VALIDATION =====
    
    // Check if fields are empty
    if (!email || !password) {
      throw Error("All fields must be filled");
    }

    // Find user by email in database
    const user = await User.findOne({ email });
    if (!user) {
      throw Error("Incorrect email");
    }

    // ===== COMPARE PASSWORD =====
    
    // Compare plain password with hashed password
    // bcrypt.compare() returns true/false
    const match = await bcrypt.compare(password, user.password);
    
    if (!match) {
      throw Error("Incorrect password");
    }

    // ===== SUCCESS =====
    
    // Send success response with user data
    res.status(200).json({ user });

  } catch (error) {
    // Send error response
    res.status(400).json({ error: error.message });
  }
};

module.exports = { signupUser, loginUser };
```

**Key Points:**

**Signup Function:**
- Validates email format (using `validator` library)
- Validates password strength (8+ chars, mixed case, numbers, symbols)
- Checks for duplicate emails
- **Hashes password** before saving to database
- Never stores plain text passwords!

**Login Function:**
- Finds user by email
- Uses `bcrypt.compare()` to verify password
- Returns user if credentials are correct

---

### Step 5: Create Routes

**File:** `routes/userRouter.js`

```javascript
const express = require('express')
const { loginUser, signupUser } = require('../controllers/userController')

const router = express.Router()

// POST /api/user/signup
// Expects: { email, password }
router.post('/signup', signupUser)

// POST /api/user/login
// Expects: { email, password }
router.post('/login', loginUser)

module.exports = router
```

---

### Step 6: Setup Express Server

**File:** `index.js`

```javascript
// Load environment variables from .env
require("dotenv").config();

const cors = require("cors");
const express = require("express");
const userRoutes = require("./routes/userRouter");
const connectDB = require("./config/db");

// Create Express app
const app = express();

// ===== MIDDLEWARE =====

// CORS: Allow requests from other origins (frontend)
app.use(cors());

// Parse JSON in request body
app.use(express.json());

// ===== DATABASE CONNECTION =====

// Connect to MongoDB
connectDB();

// ===== ROUTES =====

// All /api/user/* routes go to userRouter
app.use("/api/user", userRoutes);

// ===== START SERVER =====

const port = process.env.PORT || 4000;
app.listen(port, () => {
  console.log(`Server is running on http://localhost:${port}`);
});
```

**Middleware Explanation:**
- `cors()`: Allow requests from different domains (frontend)
- `express.json()`: Parse JSON data from request body

---

## Testing with Postman

### Installation
1. Download Postman: https://www.postman.com/downloads/
2. Install and open it

### Start Your Server

In your terminal:
```bash
npm run dev
```

You should see:
```
Server is running on http://localhost:4000
MongoDB Connected: localhost
```

---

### Test 1: Signup (Create New User)

**Step 1:** Open Postman and create a new request

| Setting | Value |
|---------|-------|
| Method | POST |
| URL | `http://localhost:4000/api/user/signup` |

**Step 2:** Click **Body** tab ‚Üí Select **raw** ‚Üí Select **JSON**

**Step 3:** Paste this JSON:

```json
{
  "email": "john@example.com",
  "password": "4wa95=Vx#"
}
```

**Step 4:** Click **Send**

**Expected Response (Success):**
```json
{
  "user": {
    "_id": "507f1f77bcf86cd799439011",
    "email": "john@example.com",
    "password": "$2b$10$N9qo8uLOickgx2ZMRZoMyeIjZAgcg7b3XeKeUxWdeS86E36P4/DJm",
    "__v": 0
  }
}
```

**Notice:** The password in response is HASHED, not the original password!

---

### Test 2: Try Signup with Invalid Email

**Request Body:**
```json
{
  "email": "not-an-email",
  "password": "Password123!"
}
```

**Expected Error Response:**
```json
{
  "error": "Email not valid"
}
```

---

### Test 3: Try Signup with Weak Password

**Request Body:**
```json
{
  "email": "jane@example.com",
  "password": "weak"
}
```

**Expected Error Response:**
```json
{
  "error": "Password not strong enough"
}
```

**Password Requirements:**
- ‚úì At least 8 characters
- ‚úì At least 1 uppercase letter (A-Z)
- ‚úì At least 1 lowercase letter (a-z)
- ‚úì At least 1 number (0-9)
- ‚úì At least 1 symbol (!@#$%^&*)

**Examples:**
- ‚úì `Password123!` - Valid
- ‚úì `SecureP@ss99` - Valid
- ‚úó `password123!` - No uppercase
- ‚úó `PASSWORD123!` - No lowercase
- ‚úó `Password!` - No number
- ‚úó `Password123` - No symbol

---

### Test 4: Try Signup with Duplicate Email

**Request Body (same email as Test 1):**
```json
{
  "email": "john@example.com",
  "password": "AnotherPassword123!"
}
```

**Expected Error Response:**
```json
{
  "error": "Email already in use"
}
```

---

### Test 5: Login with Correct Credentials

**URL:** `http://localhost:4000/api/user/login`

**Request Body:**
```json
{
  "email": "john@example.com",
  "password": "Password123!"
}
```

**Expected Success Response:**
```json
{
  "user": {
    "_id": "507f1f77bcf86cd799439011",
    "email": "john@example.com",
    "password": "$2b$10$N9qo8uLOickgx2ZMRZoMyeIjZAgcg7b3XeKeUxWdeS86E36P4/DJm",
    "__v": 0
  }
}
```

**What Happened Behind the Scenes:**
1. User submits plain password: `Password123!`
2. bcrypt.compare() hashes it with embedded salt
3. Compares result with stored hash
4. Hashes match ‚Üí Login successful!

---

### Test 6: Login with Wrong Password

**Request Body:**
```json
{
  "email": "john@example.com",
  "password": "WrongPassword123!"
}
```

**Expected Error Response:**
```json
{
  "error": "Incorrect password"
}
```

---

### Test 7: Login with Non-existent Email

**Request Body:**
```json
{
  "email": "nonexistent@example.com",
  "password": "Password123!"
}
```

**Expected Error Response:**
```json
{
  "error": "Incorrect email"
}
```

---

### Test 8: Login with Empty Fields

**Request Body:**
```json
{
  "email": "",
  "password": ""
}
```

**Expected Error Response:**
```json
{
  "error": "All fields must be filled"
}
```

---

## Common Issues & Troubleshooting

### Issue 1: "Cannot find module 'bcryptjs'"

**Solution:**
```bash
npm install bcryptjs
```

### Issue 2: "Cannot find module 'validator'"

**Solution:**
```bash
npm install validator
```

### Issue 3: "MongoDB Connection Error"

**Causes & Solutions:**

**A) Local MongoDB not running:**
```bash
# Windows
# Make sure MongoDB Service is running
net start MongoDB
```

**B) Wrong MONGO_URI in .env:**
```env
# For local MongoDB:
MONGO_URI=mongodb://localhost:27017/w6-fepp

# For MongoDB Atlas (cloud):
MONGO_URI=mongodb+srv://username:password@cluster.mongodb.net/w6-fepp
```

### Issue 4: "duplicate key error: E11000"

**Cause:** Trying to signup with an email that already exists.

**Solution:** Use a different email address.

### Issue 5: "Cannot POST /api/user/signup"

**Cause:** Route not registered properly.

**Solution:** Check:
1. Route is registered in `index.js`: `app.use("/api/user", userRoutes)`
2. Route exists in `userRouter.js`: `router.post('/signup', signupUser)`
3. URL in Postman is correct: `http://localhost:4000/api/user/signup`

### Issue 6: "SyntaxError: Unexpected token < in JSON"

**Cause:** Response is HTML (error page) instead of JSON.

**Solution:**
1. Check server is running and connected to MongoDB
2. Check URL is correct
3. Check request body is valid JSON

### Issue 7: Password Works in Signup but Not in Login

**Cause:** Probably typo or case-sensitive issue.

**Solution:** Copy-paste the exact password from your first request.

---

## Learning Outcomes

By completing this pair programming task, you'll understand:

‚úì How Express routes work  
‚úì How MongoDB stores and retrieves data  
‚úì How bcrypt secures passwords  
‚úì Why you should NEVER store plain text passwords  
‚úì How to validate user input  
‚úì How to handle errors in async/await  
‚úì How to test APIs with Postman  

---

## Next Steps (Advanced)

Once you master this, explore:

1. **JWT Tokens** - Create a session token after login
2. **Password Reset** - Email-based password recovery
3. **Rate Limiting** - Prevent brute force attacks
4. **Password Hashing with Argon2** - More secure than bcrypt
5. **Two-Factor Authentication (2FA)** - Extra security layer

---

## Quick Reference: bcrypt Passwords

| Test Case | Email | Password | Expected Result |
|-----------|-------|----------|-----------------|
| Valid signup | `john@ex.com` | `"4wa95=Vx#!` | ‚úì Success |
| Invalid email | `notanemail` | `"4wa95=Vx#!` | ‚úó Error |
| Weak password | `john@ex.com` | `weak` | ‚úó Error |
| Duplicate email | (existing) | `"4wa95=Vx#!` | ‚úó Error |
| Correct login | `john@ex.com` | `"4wa95=Vx#!` | ‚úì Success |
| Wrong password | `john@ex.com` | `WrongPass123!` | ‚úó Error |
| Non-existent | `fake@ex.com` | `"4wa95=Vx#!` | ‚úó Error |
| Empty fields | `` | `` | ‚úó Error |

---

## Files Summary

| File | Purpose |
|------|---------|
| `index.js` | Express server setup & middleware |
| `config/db.js` | MongoDB connection |
| `models/userModel.js` | User database schema |
| `controllers/userController.js` | Signup/Login business logic |
| `routes/userRouter.js` | API endpoint definitions |
| `.env` | Secret configuration (DO NOT COMMIT) |
| `package.json` | Project dependencies |

---

## Commands Reference

```bash
# Install dependencies
npm install

# Start server (development with nodemon)
npm run dev

# Start server (production)
npm start

# Run tests (if configured)
npm test
```

---

Happy coding! üöÄ

